
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        """Check if the queue is empty."""
        return len(self.items) == 0

    def enqueue(self, item):
        """Add an item to the end of the queue."""
        self.items.append(item)

    def dequeue(self):
        """Remove an item from the front of the queue."""
        if not self.is_empty():
            return self.items.pop(0)
        else:
            return None

    def size(self):
        """Return the number of items in the queue."""
        return len(self.items)

    def front(self):
        """Return the first item in the queue without removing it."""
        if not self.is_empty():
            return self.items[0]
        else:
            return None

    def __str__(self):
        """Return the string representation of the queue."""
        return " -> ".join(str(item) for item in self.items)

class Ingredient:
    def __init__(self, name, quantity, unit_price, reorder_threshold):
        self.name = name
        self.quantity = quantity
        self.unit_price = unit_price
        self.reorder_threshold = reorder_threshold

    def update_quantity(self, amount):
        """Update ingredient quantity after an order is processed."""
        self.quantity += amount

    def is_low(self):
        """Check if the stock is below the reorder threshold."""
        return self.quantity < self.reorder_threshold

    def __str__(self):
        return f"{self.name}: {self.quantity} units, Reorder Threshold: {self.reorder_threshold}"

class MenuItem:
    def __init__(self, name, ingredients):
        """
        name: Name of the dish.
        ingredients: List of tuples (Ingredient object, quantity required for the dish).
        """
        self.name = name
        self.ingredients = ingredients

    def use_ingredients(self, quantity_sold):
        """Update ingredient quantities based on the dish being ordered."""
        for ingredient, qty in self.ingredients:
            ingredient.update_quantity(-qty * quantity_sold)

    def __str__(self):
        return f"Dish: {self.name}"

class Inventory:
    def __init__(self):
        self.ingredients = {}  # {name: Ingredient}
        self.dishes = []  # List of MenuItem objects

    def add_ingredient(self, ingredient):
        """Add ingredients to inventory."""
        self.ingredients[ingredient.name] = ingredient

    def add_dish(self, dish):
        """Add menu items to the system."""
        self.dishes.append(dish)

    def process_order(self, dish_name, quantity_sold):
        """Process an order, update ingredient quantities."""
        dish = next((d for d in self.dishes if d.name == dish_name), None)
        if dish:
            dish.use_ingredients(quantity_sold)
            print(f"Order for {dish_name} (x{quantity_sold}) has been processed.")
        else:
            print(f"Dish {dish_name} not found.")

    def check_inventory(self):
        """Check ingredients against reorder threshold and alert if low stock."""
        reorder_queue = Queue()
        for ingredient in self.ingredients.values():
            if ingredient.is_low():
                reorder_queue.enqueue(ingredient)
        return reorder_queue

    def process_sales_data(self, sales_file):
        """Process sales data from a .txt file and update inventory."""
        with open(sales_file, 'r') as file:
            for line in file.readlines()[1:]:  # Skip the header line
                date, dish_name, quantity_sold = line.strip().split(',')
                self.process_order(dish_name, int(quantity_sold))

    def process_dishes_data(self, dishes_file):
        """Process dishes data (dishes and their ingredients) from a file."""
        with open(dishes_file, 'r') as file:
            for line in file.readlines()[1:]:  # Skip the header line
                dish_name, ingredient_name, quantity_needed = line.strip().split(',')

            # If the ingredient exists, use it; otherwise, create a new one
            if ingredient_name not in self.ingredients:
                print(f"Ingredient {ingredient_name} not found, adding to inventory...")
                ingredient = Ingredient(ingredient_name, 100, 1.0, 10)  # Default initial values for new ingredients
                self.add_ingredient(ingredient)

            ingredient = self.ingredients[ingredient_name]
            menu_item = next((d for d in self.dishes if d.name == dish_name), None)

            if not menu_item:
                # Create a new menu item if it doesn't exist
                menu_item = MenuItem(dish_name, [])
                self.add_dish(menu_item)

            # Add ingredient to the dish's ingredient list
            menu_item.ingredients.append((ingredient, quantity_needed))

def __main__():
    # Creating sample ingredients and dishes
    ingredient1 = Ingredient("Bun", 100, 0.5, 20)
    ingredient2 = Ingredient("Cheese", 50, 1.0, 10)
    ingredient3 = Ingredient("Beef Patty", 60, 2.5, 15)

    dish1 = MenuItem("Cheeseburger", [(ingredient1, 1), (ingredient2, 1), (ingredient3, 1)])
    dish2 = MenuItem("Veggie Burger", [(ingredient1, 1), (ingredient2, 1)])

    # Initialize inventory
    inventory = Inventory()
    inventory.add_ingredient(ingredient1)
    inventory.add_ingredient(ingredient2)
    inventory.add_ingredient(ingredient3)
    inventory.add_dish(dish1)
    inventory.add_dish(dish2)

    # Simulate processing sales data (here we manually add orders)
    inventory.process_order("Cheeseburger", 2)
    inventory.process_order("Veggie Burger", 5)

    # Check low stock ingredients
    reorder_queue = inventory.check_inventory()
    print("Low Stock Alert Queue:")
    while not reorder_queue.is_empty():
        ingredient = reorder_queue.dequeue()
        print(f"Reorder Needed: {ingredient}")

